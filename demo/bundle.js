/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./demo/main.js":
/*!**********************!*\
  !*** ./demo/main.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _worley_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../worley.js */ \"./worley.js\");\n/* harmony import */ var _leodeslf_vec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @leodeslf/vec.js */ \"./node_modules/@leodeslf/vec.js/vec.js\");\n\r\n\r\n\r\nlet ctx;\r\n\r\nwindow.addEventListener('load', () => {\r\n  ctx = document.getElementById('canvas').getContext('2d');\r\n  ctx.fillStyle = 'red';\r\n  draw();\r\n});\r\n\r\nconst SIDE = 300;\r\nconst HALF_SIDE = SIDE * .5;\r\nconst CENTER = new _leodeslf_vec_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(HALF_SIDE, HALF_SIDE, HALF_SIDE);\r\nconst SPOTS_N = 20;\r\nconst SPOTS = [];\r\nfor (let i = 0; i < SPOTS_N; i++) {\r\n  SPOTS[i] = _leodeslf_vec_js__WEBPACK_IMPORTED_MODULE_1__.Vec3.random();\r\n  SPOTS[i].scale(HALF_SIDE);\r\n  SPOTS[i].add(CENTER);\r\n}\r\nconst WORLEY = new _worley_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](SPOTS, '3d');\r\nconst IMAGE_DATA = new ImageData(SIDE, SIDE);\r\n\r\nfunction draw() {\r\n  for (let v = 0; v < SIDE; v++) {\r\n    for (let u = 0; u < SIDE; u++) {\r\n      const values = WORLEY.nd(new _leodeslf_vec_js__WEBPACK_IMPORTED_MODULE_1__.Vec3(u, v, 0));\r\n      const value = (values[1] - values[0]) * 2;\r\n      const index = (v * SIDE + u) * 4;\r\n      for (let rgb = 0; rgb < 3; rgb++) {\r\n        IMAGE_DATA.data[index + rgb] = value;\r\n      }\r\n      IMAGE_DATA.data[index + 3] = 255;\r\n    }\r\n  }\r\n  ctx.clearRect(0, 0, SIDE, SIDE);\r\n  ctx.putImageData(IMAGE_DATA, 0, 0);\r\n  update();\r\n  requestAnimationFrame(draw)\r\n}\r\n\r\nfunction update() {\r\n  for (let i = 0; i < SPOTS_N; i++) {\r\n    SPOTS[i].subtract(CENTER);\r\n    SPOTS[i].rotateAxisY(.0003 * (i + 1));\r\n    SPOTS[i].add(CENTER);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://@leodeslf/worley-noise/./demo/main.js?");

/***/ }),

/***/ "./worley.js":
/*!*******************!*\
  !*** ./worley.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _leodeslf_vec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @leodeslf/vec.js */ \"./node_modules/@leodeslf/vec.js/vec.js\");\n\r\n\r\nclass Worley {\r\n\t#metricName;\r\n\t#class;\r\n\t#function;\r\n\r\n\t/**\r\n\t * @param {Vec2[]|Vec3[]} spots\r\n\t * @param {'2d'|'3d'} [dimentionName]\r\n\t * @param {'euclidean'|'manhattan'|'chebyshev'|'minkowski'} [metricName]\r\n\t */\r\n\tconstructor(spots, dimentionName, metricName) {\r\n\t\tthis.#metricName = metricName;\r\n\t\tthis.dimention = dimentionName;\r\n\t\tthis.spots = spots;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {'2d'|'3d'} dimentionName\r\n\t */\r\n\tset dimention(dimentionName) {\r\n\t\tswitch (dimentionName) {\r\n\t\t\tcase '2d': this.#class = _leodeslf_vec_js__WEBPACK_IMPORTED_MODULE_0__.Vec2; break;\r\n\t\t\tcase '3d': this.#class = _leodeslf_vec_js__WEBPACK_IMPORTED_MODULE_0__.Vec3; break;\r\n\t\t\tdefault: this.#class = _leodeslf_vec_js__WEBPACK_IMPORTED_MODULE_0__.Vec2; break;\r\n\t\t}\r\n\t\tthis.metric = this.#metricName;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {'euclidean'|'manhattan'|'chebyshev'|'minkowski'} metricName\r\n\t */\r\n\tset metric(metricName) {\r\n\t\tthis.#metricName = metricName;\r\n\t\tswitch (metricName) {\r\n\t\t\tcase 'euclidean': this.#function = this.#class.distance; break;\r\n\t\t\tcase 'chebyshev': this.#function = this.#class.distanceChebyshev; break;\r\n\t\t\tcase 'manhattan': this.#function = this.#class.distanceManhattan; break;\r\n\t\t\tcase 'minkowski': this.#function = this.#class.distanceMinkowski; break;\r\n\t\t\tdefault: this.#function = this.#class.distance; break;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the distance from the first & second closest spot to the position.\r\n\t * @param {Vec2} position Current position.\r\n\t * @param {number} [e = 3] Minkowski exponent.\r\n\t * @returns {number[]}\r\n\t */\r\n\tnd(position, e = 3) {\r\n\t\tlet stDistance = Infinity;\r\n\t\tlet ndDistance = Infinity;\r\n\t\tfor (let i = 0; i < this.spots.length; i++) {\r\n\t\t\tlet distance = this.#function(position, this.spots[i], e);\r\n\t\t\tif (distance < stDistance) {\r\n\t\t\t\t[ndDistance, stDistance] = [stDistance, distance];\r\n\t\t\t} else if (distance < ndDistance) {\r\n\t\t\t\tndDistance = distance;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn [stDistance, ndDistance];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the distance from the first closest spot to the position.\r\n\t * @param {Vec2} position Current position.\r\n\t * @param {number} [e = 3] Minkowski exponent.\r\n\t * @returns {number}\r\n\t */\r\n\tst(position, e = 3) {\r\n\t\tlet stDistance = Infinity;\r\n\t\tfor (let i = 0; i < this.spots.length; i++) {\r\n\t\t\tlet distance = this.#function(position, this.spots[i], e);\r\n\t\t\tif (distance < stDistance) stDistance = distance;\r\n\t\t}\r\n\t\treturn stDistance;\r\n\t}\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Worley);\r\n\n\n//# sourceURL=webpack://@leodeslf/worley-noise/./worley.js?");

/***/ }),

/***/ "./node_modules/@leodeslf/vec.js/vec.js":
/*!**********************************************!*\
  !*** ./node_modules/@leodeslf/vec.js/vec.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vec2\": () => (/* binding */ Vec2),\n/* harmony export */   \"Vec3\": () => (/* binding */ Vec3),\n/* harmony export */   \"Vec4\": () => (/* binding */ Vec4)\n/* harmony export */ });\n/**\n * A vector library for JavaScript.\n * \n * MIT License.\n * Copyright (c) 2018 Leonardo de S.L.F.\n * http://leodeslf.com/\n */\n\n/**\n * A two-dimensional vector class.\n */\nclass Vec2 {\n  /**\n   * Creates a two-dimensional vector pointing to X and Y.\n   * @param {number} [x = 0] A numeric expression.\n   * @param {number} [y = 0] A numeric expression.\n   */\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * @param {Vec2} a A vector.\n   * @param {Vec2} b A vector.\n   * @returns {Vec2} A new vector equals to A plus B.\n   */\n  static add(a, b) {\n    return new Vec2(\n      a.x + b.x,\n      a.y + b.y\n    );\n  }\n\n  /**\n   * Returns the angle between A and B, interval (-PI, PI].\n   * @param {Vec2} a A vector.\n   * @param {Vec2} b A vector.\n   * @returns {number} Value in radians.\n   */\n  static angleBetween(a, b) {\n    return Math.atan2(\n      b.y * a.x - b.x * a.y,\n      b.x * a.x + b.y * a.y\n    )\n  }\n\n  /**\n   * @param {Vec2} a A vector.\n   * @returns {Vec2} A new vector identical to A.\n   */\n  static clone(a) {\n    return new Vec2(\n      a.x,\n      a.y\n    );\n  }\n\n  /**\n   * @param {Vec2} a A vector.\n   * @param {Vec2} b A vector.\n   * @returns {number} The (Euclidian) distance from A to B.\n   */\n  static distance(a, b) {\n    const ABX = (a.x - b.x);\n    const ABY = (a.y - b.y);\n    return Math.sqrt(\n      ABX * ABX +\n      ABY * ABY\n    );\n  }\n\n  /**\n   * \"Also known as the Chessboard distance, it is somewhat similar\n   * to the Manhattan distance, but with 45 degrees rotation.\"\n   * @param {Vec2} a A vector.\n   * @param {Vec2} b A vector.\n   * @returns {number} Chebyshev distance from A to B.\n   */\n  static distanceChebyshev(a, b) {\n    return Math.max(\n      Math.abs(a.x - b.x),\n      Math.abs(a.y - b.y)\n    );\n  }\n\n  /**\n   * \"Inspired by the grid-like organization of Manhattan, this\n   * is distance to the nearest points when you can only travel\n   * around the boundaries.\"\n   * \n   * In other words: \n   * Only horizontal, vertical and diagonal (45 deg.) movements.\n   * @param {Vec2} a A vector.\n   * @param {Vec2} b A vector.\n   * @returns {number} Manhattan distance from A to B.\n   */\n  static distanceManhattan(a, b) {\n    return Math.sqrt(\n      Math.abs(a.x - b.x) +\n      Math.abs(a.y - b.y)\n    );\n  }\n\n  /**\n   * It takes an exponent parameter (e), and the results can be similar\n   * or even equivalent to Chebyshev, Euclidian and Manhattan metrics.\n   * - When powers to 1: It'll be equivalent to Manhattan distance.\n   * - When powers to 2: It'll be equivalent to Euclidian distance.\n   * - When powers to infinite: It'll be equivalent to Chebyshev distance.\n   * @param {Vec2} a A vector.\n   * @param {Vec2} b A vector.\n   * @param {number} e A numeric expression.\n   * @returns {number} Minkowski distance from A to B.\n   */\n  static distanceMinkowski(a, b, e) {\n    if (e === 0) {\n      console.error(\"Cannot divide by zero.\");\n      return NaN;\n    }\n    return (\n      Math.abs(a.x - b.x) ** e +\n      Math.abs(a.y - b.y) ** e\n    ) ** (1 / e);\n  }\n\n  /**\n   * The sum of the product of each component.\n   * @param {Vec2} a A vector.\n   * @param {Vec2} b A vector.\n   * @returns {number} The dot product of these two vectors.\n   */\n  static dot(a, b) {\n    return (\n      a.x * b.x +\n      a.y * b.y\n    );\n  }\n\n  /**\n   * Returns true if vectors A and B are equal (identical components).\n   * @param {Vec2} a A vector.\n   * @param {Vec2} b A vector.\n   * @returns {boolean} The deep comparison result.\n   */\n  static equal(a, b) {\n    return (\n      a.x === b.x &&\n      a.y === b.y\n    );\n  }\n\n  /**\n   * @param {Vec2} a A vector.\n   * @returns {Vec2} A new vector identical to A.\n   * @deprecated\n   */\n  static fromCopy(a) {\n    return new Vec2(\n      a.x,\n      a.y\n    );\n  }\n\n  /**\n   * @param {number} r A numeric expression.\n   * @param {number} phi Angle from positive x-axis in radians.\n   * @returns {Vec2} A new vector created from Polar Coordinates.\n   */\n  static fromPolarCoords(r, phi) {\n    return new Vec2(\n      r * Math.cos(phi),\n      r * Math.sin(phi)\n    );\n  }\n\n  /**\n   * Linearly interpolates between a and b. Parameter t is clamped to the\n   * range of [0, 1].\n   * - Returns a when t = 0.\n   * - Returns b when t = 1.\n   * - Returns the point midway between a and b when t = 0.5.\n   * @param {Vec2} a A vector.\n   * @param {Vec2} b A vector.\n   * @param {number} t The interpolant aka. alpha.\n   * @returns {Vec2} Linear interpolation between a and b.\n   */\n  static lerp(a, b, t) {\n    if (t > 1) t = 1;\n    else if (t < 0) t = 0;\n    return new Vec2(\n      a.x + (b.x - a.x) * t,\n      a.y + (b.y - a.y) * t\n    );\n  }\n\n  /**\n   * Orthogonal projection of A onto B.\n   * @param {Vec2} a A vector.\n   * @param {Vec2} b A vector.\n   * @returns {Vec2} The component of A projected on B (in direction of B).\n   */\n  static project(a, b) {\n    return Vec2.clone(b)\n      .normalize()\n      .scale(a.magnitude * Math.cos(Vec2.angleBetween(a, b)));\n  }\n\n  /**\n   * Returns a new vector with a random magnitude (between max and min) and\n   * a uniformly distributed direction.\n   * @param {number} [min = 0] Minumim magnitude value (inclusive).\n   * @param {number} [max = 1] Maximum magnitude value (exclusive).\n   * @returns {Vec2} A new vector.\n   */\n  static random(min = 0, max = 1) {\n    const R = min + Math.random() * (max - min);\n    const PHI = Math.random() * Math.PI * 2;\n    return new Vec2(\n      R * Math.cos(PHI),\n      R * Math.sin(PHI)\n    );\n  }\n\n  /**\n   * @param {Vec2} a A vector.\n   * @param {Vec2} b A vector.\n   * @returns {Vec2} A new vector equals to A minus B.\n   */\n  static subtract(a, b) {\n    return new Vec2(\n      a.x - b.x,\n      a.y - b.y\n    );\n  }\n\n  /**\n   * Angle relative to the positive x-axis, signed, interval (-PI, PI].\n   * @returns {number} Value in radians.\n   */\n  get angleX() {\n    return Math.atan2(\n      this.y,\n      this.x\n    );\n  }\n\n  /**\n   * Angle relative to the positive y-axis, signed, interval (-PI, PI].\n   * @returns {number} Value in radians.\n   */\n  get angleY() {\n    return Math.atan2(\n      this.x,\n      this.y\n    );\n  }\n\n  /**\n   * @returns {number} The magnitude of this vector.\n   */\n  get magnitude() {\n    return Math.sqrt(\n      this.x * this.x +\n      this.y * this.y\n    );\n  }\n\n  /**\n   * A shortcut for an iterable array or values.\n   * @returns {number[]} An array of numbers.\n   */\n  get xy() {\n    return [this.x, this.y];\n  }\n\n  /**\n   * Limits the maximum length of this vector.\n   * @param {number} max A numeric expression.\n   * @deprecated\n   */\n  set limit(max) {\n    if (this.magnitude > max) {\n      this.normalize();\n      this.x *= max;\n      this.y *= max;\n    }\n  }\n\n  /**\n   * Sets the magnitude of this vector.\n   * @param {number} m A numeric expression.\n   */\n  set magnitude(m) {\n    this.normalize();\n    this.x *= m;\n    this.y *= m;\n  }\n\n  /**\n   * Sets all the components.\n   * @param {number[]} xy An array of numbers.\n   */\n  set xy(xy) {\n    this.x = xy[0];\n    this.y = xy[1];\n  }\n\n  /**\n   * Adds A to this vector.\n   * @param {Vec2} a A vector.\n   * @returns {Vec2} This vector.\n   */\n  add(a) {\n    this.x += a.x;\n    this.y += a.y;\n    return this;\n  }\n\n  /**\n   * Keeps the vector's magnitude between the given values, minimum\n   * and maximum (inclusive).\n   * @param {number} min A numeric expression.\n   * @param {number} max A numeric expression.\n   * @returns {Vec2} This vector.\n   */\n  clamp(min, max) {\n    const M = this.magnitude;\n    if (M > max) this.magnitude = max;\n    else if (M < min) this.magnitude = min;\n    return this;\n  }\n\n  /**\n   * Copy the coordinates of A to this vector.\n   * @param {Vec2} a A vector.\n   * @returns {Vec2} This vector.\n   */\n  copy(a) {\n    this.x = a.x;\n    this.y = a.y;\n    return this;\n  }\n\n  /**\n   * Limits the maximim length of this vector.\n   * @param {number} max A numeric expression.\n   * @returns {Vec2} This vector.\n   */\n  limitMaxMagnitude(max) {\n    const M = this.magnitude;\n    if (M > max && M > 0) {\n      this.normalize();\n      this.x *= max;\n      this.y *= max;\n    }\n    return this;\n  }\n\n  /**\n   * Limits the minimim length of this vector.\n   * @param {number} min A numeric expression.\n   * @returns {Vec2} This vector.\n   */\n  limitMinMagnitude(min) {\n    const M = this.magnitude;\n    if (M < min && M > 0) {\n      this.normalize();\n      this.x *= min;\n      this.y *= min;\n    }\n    return this;\n  }\n\n  /**\n   * Sets the magnitude of this vector to 1 (Unit Vector).\n   * @returns {Vec2} This vector.\n   */\n  normalize() {\n    let m = this.magnitude;\n    if (m === 0) return this;\n    else m = 1 / m;\n    this.x *= m;\n    this.y *= m;\n    return this;\n  }\n\n  /**\n   * Rotates this vector on z-axis by phi.\n   * @param {number} phi Angle in radians.\n   * @returns {Vec2} This vector.\n   */\n  rotateAxisZ(phi) {\n    [this.x, this.y] = [\n      this.x * Math.cos(phi) + this.y * -Math.sin(phi),\n      this.x * Math.sin(phi) + this.y * Math.cos(phi)\n    ];\n    return this;\n  }\n\n  /**\n   * Scales this vector by a given factor.\n   * @param {number} f A numeric expression.\n   * @returns {Vec2} This vector.\n   */\n  scale(f) {\n    this.x *= f;\n    this.y *= f;\n    return this;\n  }\n\n  /**\n   * Subtracts A from this vector.\n   * @param {Vec2} a A vector.\n   * @returns {Vec2} This vector.\n   */\n  subtract(a) {\n    this.x -= a.x;\n    this.y -= a.y;\n    return this;\n  }\n}\n\n/**\n * A three-dimensional vector class.\n */\nclass Vec3 {\n  /**\n   * Creates a three-dimensional vector pointing to X, Y and Z.\n   * @param {number} [x = 0] A numeric expression.\n   * @param {number} [y = 0] A numeric expression.\n   * @param {number} [z = 0] A numeric expression.\n   */\n  constructor(x = 0, y = 0, z = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  /**\n   * @param {Vec3} a A vector.\n   * @param {Vec3} b A vector.\n   * @returns {Vec3} A new vector equals to A plus B.\n   */\n  static add(a, b) {\n    return new Vec3(\n      a.x + b.x,\n      a.y + b.y,\n      a.z + b.z\n    );\n  }\n\n  /**\n   * Returns the angle between A and B, interval [0, PI].\n   * @param {Vec3} a A vector.\n   * @param {Vec3} b A vector.\n   * @returns {number} Value in radians.\n   */\n  static angleBetween(a, b) {\n    const MA = a.magnitude;\n    const MB = b.magnitude;\n    if (MA === 0 || MB === 0) {\n      console.error(\"Cannot divide by zero.\");\n      return NaN;\n    }\n    return Math.acos((\n      a.x * b.x +\n      a.y * b.y +\n      a.z * b.z\n    ) / (MA * MB));\n  }\n\n  /**\n   * @param {Vec3} a A vector.\n   * @returns {Vec3} A new vector identical to A.\n   */\n  static clone(a) {\n    return new Vec3(\n      a.x,\n      a.y,\n      a.z\n    );\n  }\n\n  /**\n   * Gives a vector which is perpendicular to both vectors A and B.\n   * @param {Vec3} a A vector.\n   * @param {Vec3} b A vector.\n   * @returns {Vec3} A new vector, the cross product of A and B.\n   */\n  static cross(a, b) {\n    return new Vec3(\n      (a.y * b.z - a.z * b.y),\n      (a.z * b.x - a.x * b.z),\n      (a.x * b.y - a.y * b.x)\n    );\n  }\n\n  /**\n   * @param {Vec3} a A vector.\n   * @param {Vec3} b A vector.\n   * @returns {number} The (Euclidian) distance from A to B.\n   */\n  static distance(a, b) {\n    const ABX = (a.x - b.x);\n    const ABY = (a.y - b.y);\n    const ABZ = (a.z - b.z);\n    return Math.sqrt(\n      ABX * ABX +\n      ABY * ABY +\n      ABZ * ABZ\n    );\n  }\n\n  /**\n   * \"Also known as the Chessboard distance, it is somewhat similar\n   * to the Manhattan distance, but with 45 degrees rotation.\"\n   * @param {Vec3} a A vector.\n   * @param {Vec3} b A vector.\n   * @returns {number} Chebyshev distance from A to B.\n   */\n  static distanceChebyshev(a, b) {\n    return Math.max(\n      Math.abs(a.x - b.x),\n      Math.abs(a.y - b.y),\n      Math.abs(a.z - b.z)\n    );\n  }\n\n  /**\n   * \"Inspired by the grid-like organization of Manhattan, this\n   * is distance to the nearest points when you can only travel\n   * around the boundaries.\"\n   * \n   * In other words: \n   * Only horizontal, vertical and diagonal (45 deg.) movements.\n   * @param {Vec3} a A vector.\n   * @param {Vec3} b A vector.\n   * @returns {number} Manhattan distance from A to B.\n   */\n  static distanceManhattan(a, b) {\n    return Math.sqrt(\n      Math.abs(a.x - b.x) +\n      Math.abs(a.y - b.y) +\n      Math.abs(a.z - b.z)\n    );\n  }\n\n  /**\n   * It takes an exponent parameter (e), and the results can be similar\n   * or even equivalent to Chebyshev, Euclidian and Manhattan metrics.\n   * - When powers to 1: It'll be equivalent to Manhattan distance.\n   * - When powers to 2: It'll be equivalent to Euclidian distance.\n   * - When powers to infinite: It'll be equivalent to Chebyshev distance.\n   * @param {Vec3} a A vector.\n   * @param {Vec3} b A vector.\n   * @param {number} e A numeric expression.\n   * @returns {number} Minkowski distance from A to B.\n   */\n  static distanceMinkowski(a, b, e) {\n    if (e === 0) {\n      console.error(\"Cannot divide by zero.\");\n      return NaN;\n    }\n    return (\n      Math.abs(a.x - b.x) ** e +\n      Math.abs(a.y - b.y) ** e +\n      Math.abs(a.z - b.z) ** e\n    ) ** (1 / e);\n  }\n\n  /**\n   * The sum of the product of each component.\n   * @param {Vec3} a A vector.\n   * @param {Vec3} b A vector.\n   * @returns {number} The dot product of these two vectors.\n   */\n  static dot(a, b) {\n    return (\n      a.x * b.x +\n      a.y * b.y +\n      a.z * b.z\n    );\n  }\n\n  /**\n   * Returns true if vectors A and B are equal (identical components).\n   * @param {Vec3} a A vector.\n   * @param {Vec3} b A vector.\n   * @returns {boolean} The deep comparison result.\n   */\n  static equal(a, b) {\n    return (\n      a.x === b.x &&\n      a.y === b.y &&\n      a.z === b.z\n    );\n  }\n\n  /**\n   * @param {Vec3} a A vector.\n   * @returns {Vec3} A new vector identical to A.\n   * @deprecated\n   */\n  static fromCopy(a) {\n    return new Vec3(\n      a.x,\n      a.y,\n      a.z\n    );\n  }\n\n  /**\n   * @param {number} r A numeric expression.\n   * @param {number} phi Angle from positive x-axis in radians.\n   * @param {number} z A numeric expression.\n   * @returns {Vec3} A new vector created from Cylindrical Coordinates.\n   */\n  static fromCylindricalCoords(r, phi, z) {\n    return new Vec3(\n      r * Math.cos(phi),\n      r * Math.sin(phi),\n      z\n    );\n  }\n\n  /**\n   * @param {number} r A numeric expression.\n   * @param {number} phi Angle from positive x-axis in radians.\n   * @param {number} theta Angle from positive z-axis in radians.\n   * @returns {Vec3} A new vector created from Spherical Coordinates.\n   */\n  static fromSphericalCoords(r, phi, theta) {\n    return new Vec3(\n      r * Math.sin(theta) * Math.cos(phi),\n      r * Math.sin(theta) * Math.sin(phi),\n      r * Math.cos(theta)\n    );\n  }\n\n  /**\n   * Linearly interpolates between a and b. Parameter t is clamped to the\n   * range of [0, 1].\n   * - Returns a when t = 0.\n   * - Returns b when t = 1.\n   * - Returns the point midway between a and b when t = 0.5.\n   * @param {Vec3} a A vector.\n   * @param {Vec3} b A vector.\n   * @param {number} t The interpolant aka. alpha.\n   * @returns {Vec3} Linear interpolation between a and b.\n   */\n  static lerp(a, b, t) {\n    if (t > 1) t = 1;\n    else if (t < 0) t = 0;\n    return new Vec3(\n      a.x + (b.x - a.x) * t,\n      a.y + (b.y - a.y) * t,\n      a.z + (b.z - a.z) * t\n    );\n  }\n\n  /**\n   * Orthogonal projection of A onto B.\n   * @param {Vec3} a A vector.\n   * @param {Vec3} b A vector.\n   * @returns {Vec3} The component of A projected on B (in direction of B).\n   */\n  static project(a, b) {\n    return Vec3.clone(b)\n      .normalize()\n      .scale(a.magnitude * Math.cos(Vec3.angleBetween(a, b)));\n  }\n\n  /**\n   * Returns a new vector with a random magnitude (between max and min) and\n   * a uniformly distributed direction.\n   * @param {number} [min = 0] Minumim magnitude value (inclusive).\n   * @param {number} [max = 1] Maximum magnitude value (exclusive).\n   * @returns {Vec3} A new vector.\n   */\n  static random(min = 0, max = 1) {\n    const R = min + Math.random() * (max - min);\n    const PHI = Math.random() * Math.PI * 2;\n    const THETA = Math.random() * Math.PI;\n    return new Vec3(\n      R * Math.sin(THETA) * Math.cos(PHI),\n      R * Math.sin(THETA) * Math.sin(PHI),\n      R * Math.cos(THETA)\n    );\n  }\n\n  /**\n   * @param {Vec3} a A vector.\n   * @param {Vec3} b A vector.\n   * @returns {Vec3} A new vector equals to A minus B.\n   */\n  static subtract(a, b) {\n    return new Vec3(\n      a.x - b.x,\n      a.y - b.y,\n      a.z - b.z\n    );\n  }\n\n  /**\n   * Angle relative to the x-axis, unsigned, interval [0, PI].\n   * @returns {number} Value in radians.\n   */\n  get angleX() {\n    return Math.atan2(Math.sqrt(\n      this.y * this.y +\n      this.z * this.z\n    ), this.x);\n  }\n\n  /**\n   * Angle relative to the y-axis, unsigned, interval [0, PI].\n   * @returns {number} Value in radians.\n   */\n  get angleY() {\n    return Math.atan2(Math.sqrt(\n      this.z * this.z +\n      this.x * this.x\n    ), this.y);\n  }\n\n  /**\n   * Angle relative to the z-axis, unsigned, interval [0, PI].\n   * @returns {number} Value in radians.\n   */\n  get angleZ() {\n    return Math.atan2(Math.sqrt(\n      this.x * this.x +\n      this.y * this.y\n    ), this.z);\n  }\n\n  /**\n   * Alias for z component.\n   * @returns {number} A numeric expression.\n   */\n  get b() {\n    return this.z;\n  }\n\n  /**\n   * Alias for y component.\n   * @returns {number} A numeric expression.\n   */\n  get g() {\n    return this.y;\n  }\n\n  /**\n   * @returns {number} The magnitude of this vector.\n   */\n  get magnitude() {\n    return Math.sqrt(\n      this.x * this.x +\n      this.y * this.y +\n      this.z * this.z\n    );\n  }\n\n  /**\n   * Alias for x component.\n   * @returns {number} A numeric expression.\n   */\n  get r() {\n    return this.x;\n  }\n\n  /**\n   * A shortcut for an iterable array or values.\n   * @returns {number[]} An array of numbers.\n   */\n  get rgb() {\n    return [this.x, this.y, this.z];\n  }\n\n  /**\n   * A shortcut for an iterable array or values.\n   * @returns {number[]} An array of numbers.\n   */\n  get xyz() {\n    return [this.x, this.y, this.z];\n  }\n\n  /**\n   * Alias for z component.\n   * @param {number} b A numeric expression.\n   */\n  set b(b) {\n    this.z = b;\n  }\n\n  /**\n   * Alias for y component.\n   * @param {number} g A numeric expression.\n   */\n  set g(g) {\n    this.y = g;\n  }\n\n  /**\n   * Limits the maximum length of this vector.\n   * @param {number} max A numeric expression.\n   * @deprecated\n   */\n  set limit(max) {\n    if (this.magnitude > max) {\n      this.normalize();\n      this.x *= max;\n      this.y *= max;\n      this.z *= max;\n    }\n  }\n\n  /**\n   * Sets the magnitude of this vector.\n   * @param {number} m A numeric expression.\n   */\n  set magnitude(m) {\n    this.normalize();\n    this.x *= m;\n    this.y *= m;\n    this.z *= m;\n  }\n\n  /**\n   * Alias for x component.\n   * @param {number} r A numeric expression.\n   */\n  set r(r) {\n    this.x = r;\n  }\n\n  /**\n   * Sets all the components.\n   * @param {number[]} rgb An array of numbers.\n   */\n  set rgb(rgb) {\n    this.x = rgb[0];\n    this.y = rgb[1];\n    this.z = rgb[2];\n  }\n\n  /**\n   * Sets all the components.\n   * @param {number[]} xyz An array of numbers.\n   */\n  set xyz(xyz) {\n    this.x = xyz[0];\n    this.y = xyz[1];\n    this.z = xyz[2];\n  }\n\n  /**\n   * Adds A to this vector.\n   * @param {Vec3} a A vector.\n   * @returns {Vec3} This vector.\n   */\n  add(a) {\n    this.x += a.x;\n    this.y += a.y;\n    this.z += a.z;\n    return this;\n  }\n\n  /**\n   * Keeps the vector's magnitude between the given values, minimum\n   * and maximum (inclusive).\n   * @param {number} min A numeric expression.\n   * @param {number} max A numeric expression.\n   * @returns {Vec3} This vector.\n   */\n  clamp(min, max) {\n    const M = this.magnitude;\n    if (M > max) this.magnitude = max;\n    else if (M < min) this.magnitude = min;\n    return this;\n  }\n\n  /**\n   * Copy the coordinates of A to this vector.\n   * @param {Vec3} a A vector.\n   * @returns {Vec3} This vector.\n   */\n  copy(a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.z = a.z;\n    return this;\n  }\n\n  /**\n   * Limits the maximim length of this vector.\n   * @param {number} max A numeric expression.\n   * @returns {Vec3} This vector.\n   */\n  limitMaxMagnitude(max) {\n    const M = this.magnitude;\n    if (M > max && M > 0) {\n      this.normalize();\n      this.x *= max;\n      this.y *= max;\n      this.z *= max;\n    }\n    return this;\n  }\n\n  /**\n   * Limits the minimim length of this vector.\n   * @param {number} min A numeric expression.\n   * @returns {Vec3} This vector.\n   */\n  limitMinMagnitude(min) {\n    const M = this.magnitude;\n    if (M < min && M > 0) {\n      this.normalize();\n      this.x *= min;\n      this.y *= min;\n      this.z *= min;\n    }\n    return this;\n  }\n\n  /**\n   * Sets the magnitude of this vector to 1 (Unit Vector).\n   * @returns {Vec3} This vector.\n   */\n  normalize() {\n    let m = this.magnitude;\n    if (m === 0) return this;\n    else m = 1 / m;\n    this.x *= m;\n    this.y *= m;\n    this.z *= m;\n    return this;\n  }\n\n  /**\n   * Rotates x-axis by phi.\n   * @param {number} phi Angle in radians.\n   * @returns {Vec3} This vector.\n   */\n  rotateAxisX(phi) {\n    [this.y, this.z] = [\n      this.y * Math.cos(phi) + this.z * -Math.sin(phi),\n      this.y * Math.sin(phi) + this.z * Math.cos(phi)\n    ];\n    return this;\n  }\n\n  /**\n   * Rotates y-axis by phi.\n   * @param {number} phi Angle in radians.\n   * @returns {Vec3} This vector.\n   */\n  rotateAxisY(phi) {\n    [this.x, this.z] = [\n      this.x * Math.cos(phi) + this.z * Math.sin(phi),\n      this.x * -Math.sin(phi) + this.z * Math.cos(phi)\n    ];\n    return this;\n  }\n\n  /**\n   * Rotates z-axis by phi.\n   * @param {number} phi Angle in radians.\n   * @returns {Vec3} This vector.\n   */\n  rotateAxisZ(phi) {\n    [this.x, this.y] = [\n      this.x * Math.cos(phi) + this.y * -Math.sin(phi),\n      this.x * Math.sin(phi) + this.y * Math.cos(phi)\n    ];\n    return this;\n  }\n\n  /**\n   * Scales this vector by a given factor.\n   * @param {number} f A numeric expression.\n   * @returns {Vec3} This vector.\n   */\n  scale(f) {\n    this.x *= f;\n    this.y *= f;\n    this.z *= f;\n    return this;\n  }\n\n  /**\n   * Subtracts A from this vector.\n   * @param {Vec3} a A vector.\n   * @returns {Vec3} This vector.\n   */\n  subtract(a) {\n    this.x -= a.x;\n    this.y -= a.y;\n    this.z -= a.z;\n    return this;\n  }\n}\n\n/**\n * A four-dimensional vector class.\n */\nclass Vec4 {\n  /**\n   * Creates a four-dimensional vector pointing to X, Y, Z and W.\n   * @param {number} [x = 0] A numeric expression.\n   * @param {number} [y = 0] A numeric expression.\n   * @param {number} [z = 0] A numeric expression.\n   * @param {number} [w = 0] A numeric expression.\n   */\n  constructor(x = 0, y = 0, z = 0, w = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n\n  /**\n   * @param {Vec4} a A vector.\n   * @param {Vec4} b A vector.\n   * @returns {Vec4} A new vector equals to A plus B.\n   */\n  static add(a, b) {\n    return new Vec4(\n      a.x + b.x,\n      a.y + b.y,\n      a.z + b.z,\n      a.w + b.w\n    );\n  }\n\n  /**\n   * Returns the angle between A and B, interval [0, PI].\n   * @param {Vec4} a A vector.\n   * @param {Vec4} b A vector.\n   * @returns {number} Value in radians.\n   */\n  static angleBetween(a, b) {\n    const MA = a.magnitude;\n    const MB = b.magnitude;\n    if (MA === 0 || MB === 0) {\n      console.error(\"Cannot divide by zero.\");\n      return NaN;\n    }\n    return Math.acos((\n      a.x * b.x +\n      a.y * b.y +\n      a.z * b.z +\n      a.w * b.w\n    ) / (MA * MB));\n  }\n\n  /**\n   * @param {Vec4} a A vector.\n   * @returns {Vec4} A new vector identical to A.\n   */\n  static clone(a) {\n    return new Vec4(\n      a.x,\n      a.y,\n      a.z,\n      a.w\n    );\n  }\n\n  /**\n   * @param {Vec4} a A vector.\n   * @param {Vec4} b A vector.\n   * @returns {number} The (Euclidian) distance from A to B.\n   */\n  static distance(a, b) {\n    const ABX = (a.x - b.x);\n    const ABY = (a.y - b.y);\n    const ABZ = (a.z - b.z);\n    const ABW = (a.w - b.w);\n    return Math.sqrt(\n      ABX * ABX +\n      ABY * ABY +\n      ABZ * ABZ +\n      ABW * ABW\n    );\n  }\n\n  /**\n   * \"Also known as the Chessboard distance, it is somewhat similar\n   * to the Manhattan distance, but with 45 degrees rotation.\"\n   * @param {Vec4} a A vector.\n   * @param {Vec4} b A vector.\n   * @returns {number} Chebyshev distance from A to B.\n   */\n  static distanceChebyshev(a, b) {\n    return Math.max(\n      Math.abs(a.x - b.x),\n      Math.abs(a.y - b.y),\n      Math.abs(a.z - b.z),\n      Math.abs(a.w - b.w)\n    );\n  }\n\n  /**\n   * \"Inspired by the grid-like organization of Manhattan, this\n   * is distance to the nearest points when you can only travel\n   * around the boundaries.\"\n   * \n   * In other words: \n   * Only horizontal, vertical and diagonal (45 deg.) movements.\n   * @param {Vec4} a a vector.\n   * @param {Vec4} b A vector.\n   * @returns {number} Manhattan distance from A to B.\n   */\n  static distanceManhattan(a, b) {\n    return Math.sqrt(\n      Math.abs(a.x - b.x) +\n      Math.abs(a.y - b.y) +\n      Math.abs(a.z - b.z) +\n      Math.abs(a.w - b.w)\n    );\n  }\n\n  /**\n   * It takes an exponent parameter (e), and the results can be similar\n   * or even equivalent to Chebyshev, Euclidian and Manhattan metrics.\n   * - When powers to 1: It'll be equivalent to Manhattan distance.\n   * - When powers to 2: It'll be equivalent to Euclidian distance.\n   * - When powers to infinite: It'll be equivalent to Chebyshev distance.\n   * @param {Vec4} a A vector.\n   * @param {Vec4} b A vector.\n   * @param {number} e A numeric expression.\n   * @returns {number} Minkowski distance from A to B.\n   */\n  static distanceMinkowski(a, b, e) {\n    if (e === 0) {\n      console.error(\"Cannot divide by zero.\");\n      return NaN;\n    }\n    return (\n      Math.abs(a.x - b.x) ** e +\n      Math.abs(a.y - b.y) ** e +\n      Math.abs(a.z - b.z) ** e +\n      Math.abs(a.w - b.w) ** e\n    ) ** (1 / e);\n  }\n\n  /**\n   * The sum of the product of each component.\n   * @param {Vec4} a A vector.\n   * @param {Vec4} b A vector.\n   * @returns {number} The dot product of these two vectors.\n   */\n  static dot(a, b) {\n    return (\n      a.x * b.x +\n      a.y * b.y +\n      a.z * b.z +\n      a.w * b.w\n    );\n  }\n\n  /**\n   * Returns true if vectors A and B are equal (identical components).\n   * @param {Vec4} a A vector.\n   * @param {Vec4} b A vector.\n   * @returns {boolean} The deep comparison result.\n   */\n  static equal(a, b) {\n    return (\n      a.x === b.x &&\n      a.y === b.y &&\n      a.z === b.z &&\n      a.w === b.w\n    );\n  }\n\n  /**\n   * @param {Vec4} a A vector.\n   * @returns {Vec4} A new vector identical to A.\n   * @deprecated\n   */\n  static fromCopy(a) {\n    return new Vec4(\n      a.x,\n      a.y,\n      a.z,\n      a.w\n    );\n  }\n\n  /**\n   * Linearly interpolates between a and b. Parameter t is clamped to the\n   * range of [0, 1].\n   * - Returns a when t = 0.\n   * - Returns b when t = 1.\n   * - Returns the point midway between a and b when t = 0.5.\n   * @param {Vec4} a A vector.\n   * @param {Vec4} b A vector.\n   * @param {number} t The interpolant aka. alpha.\n   * @returns {Vec4} Linear interpolation between a and b.\n   */\n  static lerp(a, b, t) {\n    if (t > 1) t = 1;\n    else if (t < 0) t = 0;\n    return new Vec4(\n      a.x + (b.x - a.x) * t,\n      a.y + (b.y - a.y) * t,\n      a.z + (b.z - a.z) * t,\n      a.w + (b.w - a.w) * t\n    );\n  }\n\n  /**\n   * Orthogonal projection of A onto B.\n   * @param {Vec4} a A vector.\n   * @param {Vec4} b A vector.\n   * @returns {Vec4} The component of A projected on B (in direction of B).\n   */\n  static project(a, b) {\n    return Vec4.clone(b)\n      .normalize()\n      .scale(a.magnitude * Math.cos(Vec4.angleBetween(a, b)));\n  }\n\n  /**\n   * Returns a new vector with a random magnitude (between max and min) and\n   * a uniformly distributed direction.\n   * @param {number} [min = 0] Minumim magnitude value (inclusive).\n   * @param {number} [max = 1] Maximum magnitude value (exclusive).\n   * @returns {Vec4} A new vector.\n   */\n  static random(min = 0, max = 1) {\n    const A = -.5 + Math.random();\n    const B = -.5 + Math.random();\n    const C = -.5 + Math.random();\n    const D = -.5 + Math.random();\n    const SQRT = Math.sqrt((1 - A * A - B * B) / (C * C + D * D));\n    const V = new Vec4(A, B, C * SQRT, D * SQRT);\n    V.magnitude = min + Math.random() * (max - min);\n    return V;\n  }\n\n  /**\n   * @param {Vec4} a A vector.\n   * @param {Vec4} b A vector.\n   * @returns {Vec4} A new vector equals to A minus B.\n   */\n  static subtract(a, b) {\n    return new Vec4(\n      a.x - b.x,\n      a.y - b.y,\n      a.z - b.z,\n      a.w - b.w\n    );\n  }\n\n  /**\n   * Alias for w component.\n   * @returns {number} A numeric expression.\n   */\n  get a() {\n    return this.w;\n  }\n\n  /**\n   * Angle relative to the w-axis, unsigned, interval [0, PI].\n   * @returns {number} Value in radians.\n   */\n  get angleW() {\n    return Math.atan2(Math.sqrt(\n      this.x * this.x +\n      this.y * this.y +\n      this.z * this.z\n    ), this.w);\n  }\n\n  /**\n   * Angle relative to the x-axis, unsigned, interval [0, PI].\n   * @returns {number} Value in radians.\n   */\n  get angleX() {\n    return Math.atan2(Math.sqrt(\n      this.y * this.y +\n      this.z * this.z +\n      this.w * this.w\n    ), this.x);\n  }\n\n  /**\n   * Angle relative to the y-axis, unsigned, interval [0, PI].\n   * @returns {number} Value in radians.\n   */\n  get angleY() {\n    return Math.atan2(Math.sqrt(\n      this.z * this.z +\n      this.w * this.w +\n      this.x * this.x\n    ), this.y);\n  }\n\n  /**\n   * Angle relative to the z-axis, unsigned, interval [0, PI].\n   * @returns {number} Value in radians.\n   */\n  get angleZ() {\n    return Math.atan2(Math.sqrt(\n      this.w * this.w +\n      this.x * this.x +\n      this.y * this.y\n    ), this.z);\n  }\n\n  /**\n   * Alias for z component.\n   * @returns {number} A numeric expression.\n   */\n  get b() {\n    return this.z;\n  }\n\n  /**\n   * Alias for y component.\n   * @returns {number} A numeric expression.\n   */\n  get g() {\n    return this.y;\n  }\n\n  /**\n   * @returns {number} The magnitude of this vector.\n   */\n  get magnitude() {\n    return Math.sqrt(\n      this.x * this.x +\n      this.y * this.y +\n      this.z * this.z +\n      this.w * this.w\n    );\n  }\n\n  /**\n   * Alias for x component.\n   * @returns {number} A numeric expression.\n   */\n  get r() {\n    return this.x;\n  }\n\n  /**\n   * A shortcut for an iterable array or values.\n   * @returns {number[]} An array of numbers.\n   */\n  get rgba() {\n    return [this.x, this.y, this.z, this.w];\n  }\n\n  /**\n   * A shortcut for an iterable array or values.\n   * @returns {number[]} An array of numbers.\n   */\n  get xyzw() {\n    return [this.x, this.y, this.z, this.w];\n  }\n\n  /**\n   * Alias for w component.\n   * @param {number} a A numeric expression.\n   */\n  set a(a) {\n    this.w = a;\n  }\n\n  /**\n   * Alias for z component.\n   * @param {number} b A numeric expression.\n   */\n  set b(b) {\n    this.z = b;\n  }\n\n  /**\n   * Alias for y component.\n   * @param {number} g A numeric expression.\n   */\n  set g(g) {\n    this.y = g;\n  }\n\n  /**\n   * Limits the maximum length of this vector.\n   * @param {number} max A numeric expression.\n   * @deprecated\n   */\n  set limit(max) {\n    if (this.magnitude > max) {\n      this.normalize();\n      this.x *= max;\n      this.y *= max;\n      this.z *= max;\n      this.w *= max;\n    }\n  }\n\n  /**\n   * Sets the magnitude of this vector.\n   * @param {number} m A numeric expression.\n   */\n  set magnitude(m) {\n    this.normalize();\n    this.x *= m;\n    this.y *= m;\n    this.z *= m;\n    this.w *= m;\n  }\n\n  /**\n   * Alias for x component.\n   * @param {number} r A numeric expression.\n   */\n  set r(r) {\n    this.x = r;\n  }\n\n  /**\n   * Sets all the components.\n   * @param {number[]} rgba An array of numbers.\n   */\n  set rgba(rgba) {\n    this.x = rgba[0];\n    this.y = rgba[1];\n    this.z = rgba[2];\n    this.w = rgba[3];\n  }\n\n  /**\n   * Sets all the components.\n   * @param {number[]} xyzw An array of numbers.\n   */\n  set xyzw(xyzw) {\n    this.x = xyzw[0];\n    this.y = xyzw[1];\n    this.z = xyzw[2];\n    this.w = xyzw[3];\n  }\n\n  /**\n   * Adds A to this vector.\n   * @param {Vec4} a A vector.\n   * @returns {Vec4} This vector.\n   */\n  add(a) {\n    this.x += a.x;\n    this.y += a.y;\n    this.z += a.z;\n    this.w += a.w;\n    return this;\n  }\n\n  /**\n   * Keeps the vector's magnitude between the given values, minimum\n   * and maximum (inclusive).\n   * @param {number} min A numeric expression.\n   * @param {number} max A numeric expression.\n   * @returns {Vec4} This vector.\n   */\n  clamp(min, max) {\n    const M = this.magnitude;\n    if (M > max) this.magnitude = max;\n    else if (M < min) this.magnitude = min;\n    return this;\n  }\n\n  /**\n   * Copy the coordinates of A to this vector.\n   * @param {Vec4} a A vector.\n   * @returns {Vec4} This vector.\n   */\n  copy(a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.z = a.z;\n    this.w = a.w;\n    return this;\n  }\n\n  /**\n   * Limits the maximim length of this vector.\n   * @param {number} max A numeric expression.\n   * @returns {Vec4} This vector.\n   */\n  limitMaxMagnitude(max) {\n    const M = this.magnitude;\n    if (M > max && M > 0) {\n      this.normalize();\n      this.x *= max;\n      this.y *= max;\n      this.z *= max;\n      this.w *= max;\n    }\n    return this;\n  }\n\n  /**\n   * Limits the minimim length of this vector.\n   * @param {number} min A numeric expression.\n   * @returns {Vec4} This vector.\n   */\n  limitMinMagnitude(min) {\n    const M = this.magnitude;\n    if (M < min && M > 0) {\n      this.normalize();\n      this.x *= min;\n      this.y *= min;\n      this.z *= min;\n      this.w *= min;\n    }\n    return this;\n  }\n\n  /**\n   * Sets the magnitude of this vector to 1 (Unit Vector).\n   * @returns {Vec4} This vector.\n   */\n  normalize() {\n    let m = this.magnitude;\n    if (m === 0) return this;\n    else m = 1 / m;\n    this.x *= m;\n    this.y *= m;\n    this.z *= m;\n    this.w *= m;\n    return this;\n  }\n\n  /**\n   * Scales this vector by a given factor.\n   * @param {number} f A numeric expression.\n   * @returns {Vec4} This vector.\n   */\n  scale(f) {\n    this.x *= f;\n    this.y *= f;\n    this.z *= f;\n    this.w *= f;\n    return this;\n  }\n\n  /**\n   * Subtracts A from this vector.\n   * @param {Vec4} a A vector.\n   * @returns {Vec4} This vector.\n   */\n  subtract(a) {\n    this.x -= a.x;\n    this.y -= a.y;\n    this.z -= a.z;\n    this.w -= a.w;\n    return this;\n  }\n}\n\n\n//# sourceURL=webpack://@leodeslf/worley-noise/./node_modules/@leodeslf/vec.js/vec.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./demo/main.js");
/******/ 	
/******/ })()
;